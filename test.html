<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mr.Colosseum 画像/動画 一覧</title>
<style>
  :root { color-scheme: dark; }
  body{margin:0;background:#0e0e11;color:#fff;font-family:system-ui,-apple-system,Segoe UI,Roboto,"Hiragino Kaku Gothic ProN",Meiryo,sans-serif;}
  header{position:sticky;top:0;z-index:10;background:#121218;border-bottom:1px solid rgba(255,255,255,.08);padding:10px;}
  h1{margin:0 0 8px;font-size:16px;}
  .row{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  input,button,select{font:inherit;border-radius:10px;border:1px solid rgba(255,255,255,.12);background:#1a1b20;color:#fff;padding:8px 10px}
  button{cursor:pointer}
  button.primary{background:#ffd400;color:#000;border-color:#ffd400;font-weight:700}
  button.danger{background:#ff4d4d;border-color:#ff4d4d;color:#000;font-weight:700}
  .hint{opacity:.8;font-size:12px;margin-top:6px;line-height:1.4}

  .tabs{display:flex;gap:8px;margin-top:10px;flex-wrap:wrap}
  .tab{padding:7px 10px;border-radius:999px;background:#1a1b20;border:1px solid rgba(255,255,255,.10);cursor:pointer}
  .tab.active{background:#ffd400;color:#000;border-color:#ffd400;font-weight:800}

  main{padding:10px}
  .section{display:none}
  .section.active{display:block}

  .grid{display:grid;grid-template-columns:repeat(2,1fr);gap:10px}
  @media (min-width:720px){.grid{grid-template-columns:repeat(4,1fr)}}

  .card{background:#1a1b20;border:1px solid rgba(255,255,255,.08);border-radius:14px;overflow:hidden}
  .media{display:block;width:100%;aspect-ratio:1/1;object-fit:cover;background:#0b0b0d}
  video.media{aspect-ratio:16/9}
  .meta{padding:8px 10px;font-size:12px;opacity:.9;display:flex;justify-content:space-between;gap:8px}
  .badge{font-size:11px;opacity:.9;padding:2px 8px;border-radius:999px;background:rgba(255,255,255,.08)}
  .progress{margin-top:8px;font-size:12px;opacity:.85}
  .mini{font-size:12px;opacity:.85}

  /* monster 詳細モーダル */
  .modal{position:fixed;inset:0;background:rgba(0,0,0,.65);display:none;align-items:flex-end;justify-content:center;z-index:50}
  .modal.open{display:flex}
  .sheet{width:min(920px,100%);max-height:92vh;background:#121218;border-top-left-radius:18px;border-top-right-radius:18px;border:1px solid rgba(255,255,255,.12);overflow:auto}
  .sheetHeader{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;border-bottom:1px solid rgba(255,255,255,.08);position:sticky;top:0;background:#121218}
  .sheetHeader strong{font-size:14px}
  .sheetBody{padding:12px;display:grid;gap:10px}
  .sheetGrid{display:grid;grid-template-columns:repeat(1,1fr);gap:10px}
  @media (min-width:720px){.sheetGrid{grid-template-columns:repeat(3,1fr)}}
  .sheetGrid img{width:100%;border-radius:14px;background:#0b0b0d}
</style>
</head>
<body>
<header>
  <h1>Mr.Colosseum：banner / monster / movie 一覧（存在するものだけ表示）</h1>

  <div class="row">
    <label class="mini">同時チェック
      <select id="concurrency">
        <option>6</option>
        <option>10</option>
        <option selected>16</option>
        <option>24</option>
        <option>32</option>
      </select>
    </label>

    <button id="btnStart" class="primary">スキャン開始</button>
    <button id="btnStop" class="danger">停止</button>
    <button id="btnClear">結果クリア</button>
  </div>

  <div class="row" style="margin-top:8px">
    <div class="mini"><b>banner</b> id: <input id="bannerStart" type="number" value="1" style="width:92px"> 〜 <input id="bannerEnd" type="number" value="2000000" style="width:110px"></div>
    <div class="mini"><b>monster</b> id: <input id="monsterStart" type="number" value="1" style="width:92px"> 〜 <input id="monsterEnd" type="number" value="6000" style="width:92px"></div>
    <div class="mini"><b>movie</b> id: <input id="movieStart" type="number" value="1" style="width:92px"> 〜 <input id="movieEnd" type="number" value="20000" style="width:92px"></div>
  </div>

  <div class="hint">
    ・「存在判定」は実際に読み込みを試して <code>onload/onerror</code> で決めます。<br>
    ・範囲が大きいと通信量が増えます。まずは小さい範囲で当たりを見つけてから広げるのがおすすめ。
  </div>

  <div class="tabs">
    <div class="tab active" data-tab="banner">banner</div>
    <div class="tab" data-tab="monster">monster</div>
    <div class="tab" data-tab="movie">movie</div>
  </div>

  <div id="progress" class="progress">待機中</div>
</header>

<main>
  <section id="sec-banner" class="section active">
    <div class="grid" id="grid-banner"></div>
  </section>

  <section id="sec-monster" class="section">
    <div class="grid" id="grid-monster"></div>
  </section>

  <section id="sec-movie" class="section">
    <div class="grid" id="grid-movie"></div>
  </section>
</main>

<!-- monster詳細 -->
<div class="modal" id="modal">
  <div class="sheet">
    <div class="sheetHeader">
      <strong id="modalTitle">monster</strong>
      <button id="modalClose">閉じる</button>
    </div>
    <div class="sheetBody">
      <div class="sheetGrid" id="modalGrid"></div>
    </div>
  </div>
</div>

<script>
(() => {
  const BASE = "https://cdn-masterdata.mr-colosseum.com";
  const URLS = {
    banner: (id) => `${BASE}/image/banner_${id}.png`,
    monster: (id) => `${BASE}/image/monster_${id}.png`,
    monsterG: (id) => `${BASE}/image/monster_${id}_g.png`,
    monsterD: (id) => `${BASE}/image/monster_${id}_d.png`,
    movie: (id) => `${BASE}/movie/popup_${id}.mp4`,
  };

  const el = (id) => document.getElementById(id);

  const grids = {
    banner: el("grid-banner"),
    monster: el("grid-monster"),
    movie: el("grid-movie"),
  };

  const progressEl = el("progress");

  let aborted = false;

  // ------- Tabs -------
  document.querySelectorAll(".tab").forEach(t => {
    t.addEventListener("click", () => {
      document.querySelectorAll(".tab").forEach(x => x.classList.remove("active"));
      t.classList.add("active");
      const tab = t.dataset.tab;
      document.querySelectorAll(".section").forEach(s => s.classList.remove("active"));
      el(`sec-${tab}`).classList.add("active");
    });
  });

  // ------- Modal -------
  const modal = el("modal");
  const modalGrid = el("modalGrid");
  const modalTitle = el("modalTitle");
  const closeModal = () => modal.classList.remove("open");
  el("modalClose").addEventListener("click", closeModal);
  modal.addEventListener("click", (e) => { if (e.target === modal) closeModal(); });

  // ------- Existence checks (real load) -------
  function checkImage(url, timeoutMs = 12000) {
    return new Promise((resolve) => {
      const img = new Image();
      let done = false;
      const t = setTimeout(() => { if (!done) { done = true; cleanup(false); } }, timeoutMs);

      function cleanup(ok) {
        clearTimeout(t);
        img.onload = null;
        img.onerror = null;
        // img.src を空にしてもリクエストは止まらない場合があるが、参照は切れる
        img.src = "";
        resolve(ok);
      }
      img.onload = () => { if (!done) { done = true; cleanup(true); } };
      img.onerror = () => { if (!done) { done = true; cleanup(false); } };
      // cache bust は不要（CDNの404キャッシュ回避したいなら付けられる）
      img.decoding = "async";
      img.loading = "eager";
      img.src = url;
    });
  }

  function checkVideo(url, timeoutMs = 15000) {
    return new Promise((resolve) => {
      const v = document.createElement("video");
      let done = false;
      const t = setTimeout(() => { if (!done) { done = true; cleanup(false); } }, timeoutMs);

      function cleanup(ok) {
        clearTimeout(t);
        v.onloadeddata = null;
        v.onerror = null;
        v.src = "";
        resolve(ok);
      }

      v.onloadeddata = () => { if (!done) { done = true; cleanup(true); } };
      v.onerror = () => { if (!done) { done = true; cleanup(false); } };
      v.preload = "metadata";
      v.muted = true;
      v.playsInline = true;
      v.src = url;
      // iOSでmetadataロード促進
      v.load();
    });
  }

  // ------- UI creators -------
  function addCard(type, id, url) {
    const card = document.createElement("div");
    card.className = "card";

    if (type === "movie") {
      const v = document.createElement("video");
      v.className = "media";
      v.controls = true;
      v.playsInline = true;
      v.preload = "metadata";
      v.src = url;
      card.appendChild(v);
    } else {
      const img = document.createElement("img");
      img.className = "media";
      img.loading = "lazy";
      img.decoding = "async";
      img.src = url;
      card.appendChild(img);
    }

    const meta = document.createElement("div");
    meta.className = "meta";
    meta.innerHTML = `<span>#${id}</span><span class="badge">${type}</span>`;
    card.appendChild(meta);

    if (type === "monster") {
      card.style.cursor = "pointer";
      card.addEventListener("click", () => openMonsterModal(id));
    }

    grids[type].appendChild(card);
  }

  async function openMonsterModal(id) {
    modalTitle.textContent = `monster_${id}（存在するものだけ表示）`;
    modalGrid.innerHTML = "";

    // まずメイン
    const main = URLS.monster(id);
    const g = URLS.monsterG(id);
    const d = URLS.monsterD(id);

    // 表示順：main → g → d（存在するやつだけ）
    const candidates = [
      { label: "main", url: main, check: () => checkImage(main) },
      { label: "_g", url: g, check: () => checkImage(g) },
      { label: "_d", url: d, check: () => checkImage(d) },
    ];

    modal.classList.add("open");

    for (const c of candidates) {
      const ok = await c.check();
      if (!ok) continue;
      const img = document.createElement("img");
      img.src = c.url;
      img.alt = `monster_${id}${c.label}`;
      modalGrid.appendChild(img);
    }

    if (!modalGrid.childElementCount) {
      const p = document.createElement("div");
      p.style.opacity = ".85";
      p.textContent = "画像が見つからなかった（読み込み失敗/存在しない）";
      modalGrid.appendChild(p);
    }
  }

  // ------- Scanner (with concurrency) -------
  async function runRange(type, start, end, concurrency) {
    let checked = 0;
    let found = 0;

    // ワーカー方式
    let nextId = start;

    const worker = async () => {
      while (!aborted) {
        const id = nextId++;
        if (id > end) return;

        const url = URLS[type](id);

        let ok = false;
        if (type === "movie") ok = await checkVideo(url);
        else ok = await checkImage(url);

        checked++;
        if (ok) {
          found++;
          addCard(type, id, url);
        }

        // progress
        if (checked % 20 === 0 || ok) {
          progressEl.textContent =
            `スキャン中… [${type}] ${start}〜${end} / チェック:${checked} / 見つかった数:${found} / 現在:${id}`;
        }
      }
    };

    const workers = Array.from({ length: concurrency }, () => worker());
    await Promise.all(workers);

    return { checked, found };
  }

  function clearAll() {
    Object.values(grids).forEach(g => g.innerHTML = "");
  }

  // ------- Buttons -------
  el("btnStop").addEventListener("click", () => {
    aborted = true;
    progressEl.textContent = "停止しました";
  });

  el("btnClear").addEventListener("click", () => {
    aborted = true;
    clearAll();
    progressEl.textContent = "結果をクリアしました";
  });

  el("btnStart").addEventListener("click", async () => {
    aborted = false;
    clearAll();

    const concurrency = Number(el("concurrency").value) || 16;

    const bannerStart = Number(el("bannerStart").value);
    const bannerEnd = Number(el("bannerEnd").value);

    const monsterStart = Number(el("monsterStart").value);
    const monsterEnd = Number(el("monsterEnd").value);

    const movieStart = Number(el("movieStart").value);
    const movieEnd = Number(el("movieEnd").value);

    progressEl.textContent = "開始…";

    // 重すぎるとき用：順番にやる（同時に3種類回さない）
    const r1 = await runRange("banner", bannerStart, bannerEnd, concurrency);
    if (aborted) return;

    const r2 = await runRange("monster", monsterStart, monsterEnd, concurrency);
    if (aborted) return;

    const r3 = await runRange("movie", movieStart, movieEnd, concurrency);
    if (aborted) return;

    progressEl.textContent =
      `完了 ✅ banner: ${r1.found}/${r1.checked}, monster: ${r2.found}/${r2.checked}, movie: ${r3.found}/${r3.checked}`;
  });

})();
</script>
</body>
</html>